# !!!아래의 내용은 하나도 빠짐없이 모두 숙지해야 하는 내용!!!
# 반복학습 횟수 : 1

'''
<부분집합>
어떤 집합의 부분집합 총 개수
= '공집합'을 포함한 부분 집합의 수는 2^n개
= 각 원소를 부분집합에 포함시키거나 포함시키지 않는 2가지 경우를 모든 원소에 각각 적용한 경우의 수와 같음

ex) {1, 2, 3, 4} => 2^4 = 16개
'''


'''
부분집합에 관련된 문제 예시
Q. 유한개의 정수로 이루어진 집합이 있을 때, 부분집합 중에서 그 집합의 원소를 모두 더한 값이 0이되는 경우가 있는지 알아내는 문제
ex) {-7, -3, -2, 5, 8} 의 부분집합 {-3, -2, 5}원소의 총 합은 0이다.
풀이과정 : 주어진 집합의 모든 부분 집합을 생성하는 방법을 생각한 후 각 부분 집합의 합을 계산(완전 검색기법)
아래의 내용은 어떤 집합의 모든 부분 집합을 생성하는 방법을 다룬다.
'''

# <어떤 집합의 모든 부분 집합을 생성하는 방법>
# 각 원소를 부분집합에 포함시키거나 포함시키지 않는 2가지 경우를 모든 원소에 각각 적용
# 이를 위해 집합의 원소 개수만큼 아래와 같이 bit 배열을 생성하고, 각각의 자리가 0 또는 1의 값을 가지는 방식으로 부분집합에 포함유무를 나타냄.
# ex) arr = {1, 2, 3, 4} 라는 집합이 있을 때 bit배열을 다음과 같이 사용한다.
#    [0, 0, 0, 0] = {}
#    [1, 0, 0, 1] = {1, 4}
#    [1, 1, 1, 1] = {1,2,3,4}


######### 부분 집합을 모두 구하는 알고리즘1(조합가능한 부분집합을 간접적으로 찾아내는 코드)
bit = [0, 0, 0, 0] # 집합 원소의 개수가 4개인 경우의 예시

for i in range(2):
    bit[0] = i
    for j in range(2):
        bit[1] = j
        for k in range(2):
            bit[2] = k
            for l in range(2):
                bit[3] = l
                print(bit)

######### 부분 집합을 모두 구하는 알고리즘2(비트연산자를 이용한 좀 더 간결한 코드, 알고리즘 1을 생략해버리는 코드)
''' a << b : a를 왼쪽으로 b비트 shift시킨다.
print(1<<3) # 2^3 = 8
print(1<<4) # 2^4 = 16

<< 연산자를 이용하면 부분집합의 개수를 바로 구할 수 있다.
다음은 원소의 개수가 n개인 집합의 총 부분집합 개수
print(1<<n) # 2^n
'''

''' a & b : a와 b의 2진수를 비교해서 각 비트의 자리가 같다면1 다르면 0으로 처리한 결과가 나옴, 비트연산자이지만 결과는 1비트값이 아니라는 점!
print(8&2) # 1000 & 0010 = 0000  즉, 0이 출력됨
print(8&8) # 1000 & 1000 = 1000  즉, 8이 출력됨
print(7&2) # 0111 & 0010 = 0010  즉, 2이 출력됨

& 연산자를 이용하면 정수 n에서 j번째 비트가 1인지 아닌지를 반환받을 수 있다.
n & (1<<j) = 정수 n의 j번째 비트가 1이라면 0이 아닌 수, 정수 n의 j번째 비트가 0이라면 0을 반환  
'''

'''
원소가 6개이므로 부분집합은 2^6 즉, 64개를 만들 수 있는 상태이며 이를 6bit 숫자로 대칭시켜보면 아래와 같이 나타내진다.

000000(0) = {}
000001(1) = {4}
...
111110(62) = {3, 6, 7, 1, 5}
111111(63) = {3, 6, 7, 1, 5, 4}

각각의 비트는 각 원소의 포함유무를 결정한다고 볼 수 있으므로 아래와 같은 코드를 통해 64개의 모든 조합을 출력해 낼 수 있다. 
'''

arr = [3, 6, 7, 1, 5, 4]

arr_len = len(arr)

subset_len = 1<<arr_len # arr의 부분집합 개수

for i in range(subset_len):                # 1<<6 : 부분집합의 개수는 2^6 = 64개
    for j in range(arr_len):               # 원소의 수만큼 비트를 비교함
        if i&(1<<j):
            print(arr[j], end=',')         # i의 j번째 비트가 1이면 j번째 원소 출력
    print()