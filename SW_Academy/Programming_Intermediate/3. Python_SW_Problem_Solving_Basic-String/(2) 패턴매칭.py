
'''
<패턴 매칭>
- 본문에서 특정 문자열을 찾는 것
  ex) "abc 1, 2 ABC"에서 "1, 2"를 "one, two"로 교체하고자 할 때
      - 찾는 문자열의 뒤에있는 문자열 "ABC"를 임시 문자열에 복사해둠
      - "1, 2"를 "one, two            "로 교체하고 맨 뒤에 복사한 문자열을 복사하면 문자열 교체가 완료됨.
      - 이때 "1, 2"가 어디있는지 찾는것이 패턴매칭이다.

<패턴매칭 알고리즘>
1) 고지식한 패턴 검색 알고리즘(Brute Force)
- 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식으로 동작
- 한칸씩 이동하며 비교한다.
- 최악의 경우 시간 복잡도는 모든 위치에서 패턴을 비교해야 하므로 O(M * N)
  ex) 길이가 10000인 String에서 길이 80의 패턴을 찾는다고 할 때, 최악의 경우 약 800,000번의 비교가 일어남
- 비교횟수를 줄이기 위한 방법으로 다음의 알고리즘을 볼 수 있음.

2) KMP 알고리즘
- 패턴을 전처리해서 매칭이 실패했을 때 돌아갈 곳을 계산한 배열 next[M]을 준비해두어 비효율적인 시작을 최소화한다.
- 최악의 경우 시간복잡도 O(N)

3) 보이어-무어 알고리즘
- 오른쪽에서 왼쪽으로 비교한다는 특징.
- 대부분의 사용 소프트웨어에서 채택하고 있는 알고리즘
- 보통 상황에서 앞부분 보다 끝 부분에 가서 불일치할 확률이 높다는 성질을 이용한 것.
- 패턴의 모든 문자가 불일치하면, 이동거리는 패턴의 길이 만큼이 됨.
- 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴내에 존재할 경우 패턴에서 일치하는 문자를 찾아서 점프
- 패턴에 대해서 skip 배열이 존재
- 최악의 경우 O(mn)이지만 보통은 O(n)보다 적음

<문자열 매칭 알고리즘 비교>
m : 문자열 패턴의 길이
n : 총 문자열의 길이
                       일반적인 경우
고지식한 패턴 검색 알고리즘     O(mn)
카프-라인 알고리즘            O(n)
KMP알고리즘                 O(n)
보이어-무어 알고리즘        O(n)보다 적음 (최악의 경우 O(mn))
'''

# 고지식한 패턴 검색 알고리즘(Brute Force)
def BruteForce(pattern, text):
    p_len = len(pattern)
    t_len = len(text)

    i = 0
    j = 0

    while j < p_len and i < t_len:

        if text[i] != pattern[j]:
            i = i - j               # i는 1칸 다음으로 밀림.
            j = -1                  # j는 다음 라인의 j += 1 과 어우러져 원점으로 돌아가는 효과가 나옴, j는 패턴이 다 맞을 경우만 len(pattern) 값이 될 수 있음

        i += 1                      #
        j += 1                      #

    if j == p_len:
        return i - p_len
    else:
        return -1

pattern = "TTA"
text = "XXTTTTAACCA"
print(BruteForce(pattern, text))