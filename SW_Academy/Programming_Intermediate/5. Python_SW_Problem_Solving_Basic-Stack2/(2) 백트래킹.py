"""<백트래킹 기법의 정의>

  @ 백트래킹(Backtracking)
  해를 찾는 도중 막히면, 즉 해가 아니면 되돌아가서 다시 해를 찾아가는 기법

  @ 백트래킹으로 해결할 수 있는 문제유형
  1) 최적화문제
  2) 결정문제 : 문제의 조건을 만족하는 해가 존재하는지의 여부를 yes 또는 no 로 답하는 문제
             (미로찾기, n-Queen 문제, Map coloring, 부분 집합의 합 문제 등)

  @ 백트래킹 기법의 특징
  - 어떤 노드의 유망성을 점검한 후에 유망하지 않다고 결정되면, 그 노드의 부모로 돌아가(Backtracking) 다음 자식 노드로 감
  - 어떤 노드를 방문하였을 때, 그 노드를 포함한 경로가 해답이 될 수 없으면 그 노드는 유망하지 않다고 함.
  - 반대로, 어떤 노드를 방문하였을 때, 그 노드를 포함한 경로가 해답이 될 수 있으면 그 노드는 유망하다고 함.
  - 가지치기(Pruning) : 유망하지 않은 노드가 포함되는 경로는 더 이상 고려하지 않음.

  @ 백트래킹을 이용한 알고리즘 절차
  1. 상태 공간 Tree 의 깊이우선탐색을 실시
  2. 각 노드가 유망한지를 점검
  3. 만일 그 노드가 유망하지 않으면, 그 노드의 부모 노드로 돌아가서 검색을 계속함.

"""


"""<백트래킹 기법 vs 깊이우선탐색 비교>
  @ 백트래킹
  - 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써 시도의 횟수를 줄임.
  - 이를 가지치기(Prunning)를 통해 불필요한 경로를 조기에 차단함.
  - 모든 후보를 검사하지 않음.
  - N! 가지의 수를 가진 문제의 경우, 백트래킹을 가하면 일반적으로 경우의 수가 줄어들지만 이 역시 최악의 경우 여전히 지수함수 시간을 요하므로 처리 불가능. 
  
  @ 깊이우선탐색(DFS)
  - 모든 경로를 추적
  - N! 가지의 수를 가진 문제의 경우, DFS 를 가하면 경우의 수가 너무 많아져서 처리가 불가능함.  
  - 모든 후보를 검사함.
"""


"""<Q. 백트래킹 기법 : 미로찾기 문제해결>

  @ 미로찾기 문제
  - 입구와 출구가 주어진 미로에서 입구부터 출구까지의 경로를 찾는 문제, 이동가능 방향은 4방향으로 제한.

  @ 해결방법
  1. 이동하는 좌표 및 이동방향을 스택에 push 하여 저장한다.
  2. 이동이 불가능해질 경우 가능할 때 까지 스택에서 pop 하여 뒤로 돌아간다.
"""


"""<Q. 백트래킹 기법 : n-Queen 문제해결>

  @ n-Queen 문제
  - n * n 의 정사각형 안에 n개의 Queen 을 배치하는 문제로, 모든 Queen 은 자신의 일직선상 및 대각선상에 아무 것도 놓이지 않아야 함. 

  @ 해결방법
  - 영상 혹은 PPT 참고
  
  @ 백트래킹 vs 깊이우선탐색
  - 이 문제에서 각각의 방식은 27노드, 155노드를 탐색해야 해답을 찾을 수 있다는 차이가 있음      
"""

"""<Q. 백트래킹 기법 : Power Set(부분집합) 문제해결>

  @ Power Set 문제
  - 모든 부분집합을 구하는 문제
  - Power Set 은 어떤 집합의 공집합과 자기자신을 포함한 모든 부분집합을 의미함
  - 어떤 집합의 원소가 n일 경우 부분집합의 개수는 2^n개가 나옴

  @ 해결방법
  - 일반적인 백트래킹 접근 방법 이용.
  - n개의 원소가 들어있는 집합의 2^n개의 부분집합을 만들 때, True, False 값을 가지는 항목들로 구성된 n개의 리스트를 만드는 방법을 이용한다.
  - 여기서 리스트의 i 번째 항목은 i 번째의 원소가 부분집합의 값인지 아닌지를 타나내는 값이다.
  
  @ 실제코드
  - 아래에 있음
  - 코드를 바로 이해할라고 하기보다 PPT 를 먼저 참고하자.      
"""


"""<Q. 백트래킹 기법 : 수열생성 문제해결>
  @ 수열생성 문제
  - 위의 부분집합 문제 해결 방법을 응용하면 비슷하게 해결가능하다.
  - 한가지 예를 들면 1,2,3 을 가지고 조합가능한 모든 순서의 값을 출력하는 문제이다.
  - 123, 132, 213, 231, 312, 321 과 같이 말다.
  
  @ 실제코드
  - 아래에 있음
  - 코드를 바로 이해할라고 하기보다 PPT 를 먼저 참고하자.
"""


########################################################################

# Power Set 을 구하는 백트래킹 알고리즘
def backtrack(a, k, input):
    c = [True, False]

    # 원하는 상태에 도달했으면 결과를 출력하는 작업을 수행한다.
    if k == input:
        process_solution(a,k)  # 답이면 원하는 작업을 한다.
    # 아니면 재귀호출하여 백트래킹을 계속한다.
    else:
        k += 1
        for i in range(2):
            a[k] = c[i]
            backtrack(a, k, input)


# 부분집합을 출력함
def process_solution(a, k):
    print("(", end="")
    for i in range(k+1):
        if a[i]:
            print(i, end="")
    print(")")


input = 3                # 3이면 {1,2,3}의 모든 부분집합을 구한다는 의미.
a = [0] * (input+1)      # [0,1,0,0, ...] 이라면 {1}, [0,1,1,0, ...] 이라면 {1,2}를 의미하는 변수
backtrack(a, 0, input)   # 두번째 변수는 현재의 깊이, 세번째 변수는 최대 깊이를 의미하기도 함.
########################################################################


print()


########################################################################

# 모든 경우의 순열을 구하는 백트래킹 알고리즘
def backtrack(a, k, input):
    global MAXCANDIDATES
    c = [0] * MAXCANDIDATES

    # 원하는 상태에 도달했으면 결과를 출력하는 작업을 수행한다.
    if k == input:
        for i in range(1, k+1):
            print(a[i], end="")
        print()
    # 아니면 재귀호출하여 백트래킹을 계속한다.
    else:
        k += 1
        ncandidates = construct_candidates(a, k, input, c)
        for i in range(ncandidates):
            a[k] = c[i]
            backtrack(a, k, input)


# 뒤에 올 지원자를 구하고, 총 지원자를 반환한다.
def construct_candidates(a, k, input, c):
    in_perm = [False] * NMAX

    for i in range(1, k):
        in_perm[a[i]] = True

    ncandidates = 0

    for i in range(1, input + 1):
        if in_perm[i] == False:
            c[ncandidates] = i
            ncandidates += 1
    return ncandidates


MAXCANDIDATES = 100                # 3이면 {1,2,3}의 모든 부분집합을 구한다는 의미.
NMAX = 100
a = [0] * NMAX
backtrack(a, 0, 3)   # 두번째 변수는 현재의 깊이, 세번째 변수는 최대 깊이를 의미하기도 함.
########################################################################